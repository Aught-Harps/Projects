#include "stm32f10x.h"
#include <stdio.h>
#include <string.h>

// ------------------------- Pin Definitions -------------------------
#define MQ135_ADC_CHANNEL 0   // PA0 -> ADC1 Channel 0
#define MQ4_ADC_CHANNEL   2   // PA2 -> ADC1 Channel 2
#define ALERT_LED_PIN     13  // PC13

#define LCD_I2C_ADDR      0x27
#define I2C_TIMEOUT       10000

// ------------------------- Global Variables -------------------------
float temperature = 27.0;
float humidity = 85.0;
uint32_t rand_state = 12345;

// ------------------------- Function Prototypes -------------------------
void GPIO_Init_Custom(void);
void ADC_Init_Custom(void);
uint16_t ADC_Read(uint8_t channel);
void USART1_Init(void);
void USART1_SendString(char *str);
void delay_ms(uint32_t ms);

void I2C1_Init(void);
uint8_t I2C_WriteByte(uint8_t dev_addr, uint8_t data);
void LCD_Init(void);
void LCD_Clear(void);
void LCD_SetCursor(uint8_t row, uint8_t col);
void LCD_Print(char *str);
int my_rand(int min, int max);

// ------------------------- Main -------------------------
int main(void)
{
    SystemInit();
    GPIO_Init_Custom();
    ADC_Init_Custom();
    USART1_Init();
    I2C1_Init();
    LCD_Init();

    // Startup message
    LCD_Clear();
    LCD_SetCursor(0,0);
    LCD_Print("MQ Sensors + Sim");
    LCD_SetCursor(1,0);
    LCD_Print("Manipal Weather");
    delay_ms(1500);

    while(1)
    {
        // --- Read MQ sensors ---
        uint16_t mq135Value = ADC_Read(MQ135_ADC_CHANNEL);
        uint16_t mq4Value   = ADC_Read(MQ4_ADC_CHANNEL);

        // --- Simulate weather ---
        temperature += my_rand(-10,10) * 0.05f;
        humidity    += my_rand(-5,5) * 0.2f;
        if(temperature < 24) temperature = 24;
        if(temperature > 30) temperature = 30;
        if(humidity < 70) humidity = 70;
        if(humidity > 95) humidity = 95;

        // --- Serial output ---
        char serial_buf[128];
        snprintf(serial_buf, sizeof(serial_buf),
                 "CO2: %d  |  Methane: %d  |  Temp: %.1fÂ°C  | Humidity: %.1f%%\r\n",
                 mq135Value, mq4Value, temperature, humidity);
        USART1_SendString(serial_buf);

        // --- LCD output ---
        char lcd_buf[32];
        LCD_Clear();
        snprintf(lcd_buf,sizeof(lcd_buf),"T:%dC H:%d%%",(int)temperature,(int)humidity);
        LCD_SetCursor(0,0);
        LCD_Print(lcd_buf);

        snprintf(lcd_buf,sizeof(lcd_buf),"C:%d M:%d",mq135Value,mq4Value);
        LCD_SetCursor(1,0);
        LCD_Print(lcd_buf);

        // --- Alerts ---
        int alert = 0;
        if(mq135Value==0 || mq4Value==0) alert=1;
        if(mq135Value>1500 || mq4Value>1500) alert=1;

        if(alert)
            GPIOC->ODR &= ~(1<<ALERT_LED_PIN); // LED on
        else
            GPIOC->ODR |= (1<<ALERT_LED_PIN);  // LED off

        delay_ms(1000);
    }
}

// ------------------------- GPIO Init -------------------------
void GPIO_Init_Custom(void)
{
    // Enable clocks
    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN | RCC_APB2ENR_IOPAEN | RCC_APB2ENR_AFIOEN;

    // PC13 output for LED
    GPIOC->CRH &= ~(0xF<<20);
    GPIOC->CRH |=  (0x2<<20); // Output 2MHz push-pull

    // PA0, PA2 analog input
    GPIOA->CRL &= ~(0xF<<0);
    GPIOA->CRL &= ~(0xF<<8);
}

// ------------------------- ADC -------------------------
void ADC_Init_Custom(void)
{
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
    ADC1->CR2 |= ADC_CR2_ADON;
}

uint16_t ADC_Read(uint8_t channel)
{
    ADC1->SQR3 = channel;
    ADC1->CR2 |= ADC_CR2_ADON;
    while(!(ADC1->SR & ADC_SR_EOC));
    return ADC1->DR;
}

// ------------------------- USART -------------------------
void USART1_Init(void)
{
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_USART1EN;

    // PA9 = TX, PA10 = RX
    GPIOA->CRH &= ~((0xF<<4)|(0xF<<8));
    GPIOA->CRH |= ((0xB<<4)|(0x4<<8)); // TX push-pull 50MHz, RX input floating

    USART1->BRR = 72000000/9600; // 72MHz PCLK
    USART1->CR1 = USART_CR1_TE | USART_CR1_UE;
}

void USART1_SendString(char *str)
{
    while(*str)
    {
        while(!(USART1->SR & USART_SR_TXE));
        USART1->DR = *str++;
    }
}

// ------------------------- Delay -------------------------
void delay_ms(uint32_t ms)
{
    for(uint32_t i=0;i<ms*8000;i++) __NOP();
}

// ------------------------- Random -------------------------
int my_rand(int min,int max)
{
    rand_state = rand_state*1664525+1013904223;
    return min + (rand_state % (max-min+1));
}

// ------------------------- I2C + LCD -------------------------
void I2C1_Init(void)
{
    // I2C1 clock PB6=SCL, PB7=SDA, 100kHz
    RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;

    // GPIOB6/7 Alternate open-drain
    GPIOB->CRL &= ~(0xFF<<24);
    GPIOB->CRL |= 0xBB000000; 

    I2C1->CR2 = 36; // 36MHz APB1
    I2C1->CCR = 180;
    I2C1->TRISE = 37;
    I2C1->CR1 |= I2C_CR1_PE;
}

uint8_t I2C_WriteByte(uint8_t dev_addr, uint8_t data)
{
    // Minimal I2C write routine to PCF8574-based LCD
    I2C1->CR1 |= I2C_CR1_START;
    while(!(I2C1->SR1 & I2C_SR1_SB));
    I2C1->DR = dev_addr<<1;
    while(!(I2C1->SR1 & I2C_SR1_ADDR));
    (void)I2C1->SR2;
    I2C1->DR = data;
    while(!(I2C1->SR1 & I2C_SR1_BTF));
    I2C1->CR1 |= I2C_CR1_STOP;
    return 0;
}

// ------------------------- LCD routines -------------------------
void LCD_Init(void)
{
    // Minimal init sequence
    delay_ms(50);
    I2C_WriteByte(LCD_I2C_ADDR, 0x30);
    delay_ms(5);
    I2C_WriteByte(LCD_I2C_ADDR, 0x30);
    delay_ms(1);
    I2C_WriteByte(LCD_I2C_ADDR, 0x30);
    delay_ms(1);
    I2C_WriteByte(LCD_I2C_ADDR, 0x20); // 4-bit mode
    delay_ms(1);
}

void LCD_Clear(void)
{
    // Send clear command
    I2C_WriteByte(LCD_I2C_ADDR, 0x01);
    delay_ms(2);
}

void LCD_SetCursor(uint8_t row, uint8_t col)
{
    uint8_t addr = (row==0 ? 0x00 : 0x40) + col;
    I2C_WriteByte(LCD_I2C_ADDR, 0x80 | addr);
}

void LCD_Print(char *str)
{
    while(*str)
    {
        I2C_WriteByte(LCD_I2C_ADDR, *str++);
    }
}
